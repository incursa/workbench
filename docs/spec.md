# Workman - Work Item Management CLI

## Overview

**Workman** is a lightweight, file-based work item management CLI tool designed to help developers track tasks, bugs, spikes, and documentation within their Git repositories. It uses Markdown files with YAML front matter for work items, making them version-controlled, searchable, and easy to review in pull requests.

## What Workman Is

Workman is:
- A **CLI tool** for managing work items as Markdown files in your repository
- A **file-based** system that leverages Git for version control and history
- A **flexible** solution that works with any Git repository
- A **developer-friendly** approach to lightweight project management
- A **documentation-first** tool that encourages capturing context and decisions

## What Workman Is NOT

Workman is NOT:
- A replacement for comprehensive project management tools like Jira or Azure DevOps
- A bug tracking service (it works locally with files)
- A Git workflow manager (though it integrates with Git)
- A code generation or scaffolding tool (except for its own templates)
- Tied to any specific product or repository structure

## Core Concepts

### Workspace

A **Workspace** is the target Git repository where Workman operates. By default, Workman operates on the current directory but can target any repository path via the `--repo` flag.

Requirements:
- Must be a valid Git repository (`.git` directory exists)
- Must have a defined root directory

### Work Item

A **Work Item** is a Markdown file with YAML front matter that represents a unit of work. Work items can be:
- **BUG**: A defect or issue that needs fixing
- **TASK**: A planned piece of work or feature
- **SPIKE**: An investigation or research item

Each work item has:
- A unique ID (e.g., `BUG-0001`, `TASK-0042`, `SPIKE-0003`)
- YAML front matter with metadata (status, assignee, priority, etc.)
- Markdown content describing the work

### Spec

A **Spec** (specification) is a detailed design document stored in `/docs` that describes:
- Feature requirements
- Architecture decisions
- API designs
- Technical specifications

Specs are regular Markdown files and may reference work items.

### ADR (Architecture Decision Record)

An **ADR** captures important architectural decisions made during development. ADRs are stored in `/docs/adr` and follow a standard format:
- Title
- Status (proposed, accepted, deprecated, superseded)
- Context
- Decision
- Consequences

## Default Paths

Workman uses these default paths (configurable via `.workman.yml`):

| Purpose | Default Path | Description |
|---------|--------------|-------------|
| Active Work Items | `/work/items` | Work items currently in progress |
| Completed Work Items | `/work/done` | Archived completed work items |
| Documentation | `/docs` | Specifications, ADRs, guides |
| ADRs | `/docs/adr` | Architecture decision records |
| Templates | `/templates` | Work item and doc templates |

## Work Item Lifecycle

Work items progress through these statuses:

### Standard Statuses

1. **draft** - Initial creation, not yet ready for work
2. **ready** - Reviewed and ready to be worked on
3. **in-progress** - Actively being worked on
4. **review** - Implementation complete, awaiting review
5. **done** - Completed and verified
6. **cancelled** - Will not be completed

### Status Transitions

```
draft → ready → in-progress → review → done
  ↓       ↓          ↓           ↓
  └───────┴──────────┴───────────→ cancelled
```

When a work item is marked **done**, Workman can optionally move it from `/work/items` to `/work/done`.

## ID Conventions

Work items use prefixed sequential IDs:

- **BUG-NNNN**: Bugs and defects (e.g., `BUG-0001`, `BUG-0042`)
- **TASK-NNNN**: Tasks and features (e.g., `TASK-0001`, `TASK-0123`)
- **SPIKE-NNNN**: Spikes and investigations (e.g., `SPIKE-0001`, `SPIKE-0007`)

### ID Configuration

ID prefixes and formats are configurable in `.workman.yml`:

```yaml
id_formats:
  bug:
    prefix: "BUG"
    digits: 4
  task:
    prefix: "TASK"
    digits: 4
  spike:
    prefix: "SPIKE"
    digits: 4
```

Custom work item types can be added with their own prefixes.

### ID Generation

IDs are auto-generated by:
1. Scanning existing work items in `/work/items` and `/work/done`
2. Finding the highest number for the given type
3. Incrementing by 1
4. Zero-padding to the configured digit count

## Configuration

Workman looks for a `.workman.yml` configuration file in the repository root:

```yaml
# Example .workman.yml
paths:
  items: work/items
  done: work/done
  docs: docs
  adr: docs/adr
  templates: templates

id_formats:
  bug:
    prefix: BUG
    digits: 4
  task:
    prefix: TASK
    digits: 4
  spike:
    prefix: SPIKE
    digits: 4

default_assignee: ""
```

## Integration Points

### Git Integration

- **Git Root Detection**: Workman finds the repository root by looking for `.git`
- **Branch Operations**: Can create branches for work items (e.g., `bug/BUG-0001-description`)
- **Commit Integration**: Can reference work items in commit messages

### GitHub Integration (Optional)

When `gh` CLI is available:
- Link work items to GitHub Issues or Pull Requests
- Sync status between work items and GitHub
- Create PRs directly from work items

## Command Overview

See [commands.md](./commands.md) for detailed command reference.

Core commands:
- `workman init` - Initialize Workman in a repository
- `workman new` - Create a new work item
- `workman list` - List work items
- `workman show <id>` - Show work item details
- `workman update <id>` - Update work item status/fields
- `workman doctor` - Check environment and configuration

## Philosophy

Workman follows these principles:

1. **Files First**: Work items are files, version-controlled with your code
2. **Markdown Native**: Use standard Markdown for maximum compatibility
3. **Git-Centric**: Leverage Git for history, branching, and collaboration
4. **Tool Agnostic**: Works with any editor, any Git hosting, any workflow
5. **Minimal Overhead**: Simple YAML front matter, no database required
6. **Human Readable**: Work items are readable without special tools
7. **Automation Friendly**: Scriptable, parseable, and automatable

## Future Enhancements

See [roadmap.md](./roadmap.md) for planned features and enhancements.
