name: Quality Gate

on:
  pull_request:
    paths-ignore:
      - ".github/**"
      - "assets/**"
      - "examples/**"
  push:
    branches:
      - main
      - release/**
      - feature/**
      - features/**
      - user/**
      - users/**
      - hotfix/**
    paths-ignore:
      - ".github/**"
      - "assets/**"
      - "examples/**"

jobs:
  verify:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Restore
        run: dotnet restore Workbench.slnx

      - name: Verify formatting and analyzers
        id: format_gate
        run: dotnet format --verify-no-changes --no-restore Workbench.slnx

      - name: Build (deterministic)
        id: build_gate
        run: dotnet build Workbench.slnx --no-restore --configuration Release -warnaserror -p:ContinuousIntegrationBuild=true

      - name: Test
        id: test_unit
        run: dotnet test --project tests/Workbench.Tests/Workbench.Tests.csproj --no-build --configuration Release --logger "trx;LogFileName=quality-unit.trx" --results-directory "artifacts/test-results"

      - name: Test (integration)
        id: test_integration
        run: dotnet test --project tests/Workbench.IntegrationTests/Workbench.IntegrationTests.csproj --no-build --configuration Release --logger "trx;LogFileName=quality-integration.trx" --results-directory "artifacts/test-results"

      - name: Collect coverage (contract gate)
        id: coverage_collect
        run: dotnet test --solution Workbench.slnx --no-build --configuration Release -- --coverage --coverage-output-format cobertura --coverage-output artifacts/coverage/coverage.cobertura.xml

      - name: Verify critical coverage contract
        id: coverage_verify
        shell: pwsh
        run: ./scripts/testing/verify-critical-coverage.ps1 -ContractPath docs/30-contracts/test-gate.contract.yaml -CoverageSearchRoot tests

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-cobertura
          path: |
            tests/**/coverage.cobertura.xml

      - name: Pack (repro 1)
        id: pack_repro1
        shell: bash
        run: |
          set -euo pipefail
          rm -rf artifacts/repro1 artifacts/repro2
          mkdir -p artifacts/repro1 artifacts/repro2

          dotnet pack ./Workbench.slnx \
            -c Release \
            -p:ContinuousIntegrationBuild=true \
            -p:Deterministic=true \
            -p:EmbedUntrackedSources=true \
            -p:PackageVersion=0.0.1-ci \
            -o artifacts/repro1 \
            --no-restore

      - name: Pack (repro 2)
        id: pack_repro2
        shell: bash
        run: |
          set -euo pipefail
          dotnet pack ./Workbench.slnx \
            -c Release \
            -p:ContinuousIntegrationBuild=true \
            -p:Deterministic=true \
            -p:EmbedUntrackedSources=true \
            -p:PackageVersion=0.0.1-ci \
            -o artifacts/repro2 \
            --no-restore


      - name: Compare nupkg contents (normalized, multi-package)
        id: compare
        shell: bash
        run: |
          set -euo pipefail

          # Creates a deterministic "manifest" for a .nupkg by hashing the extracted contents,
          # excluding known non-deterministic OPC metadata produced by NuGet pack.
          normalize_manifest() {
            local nupkg="$1"
            local out="$2"
            local dir
            dir="$(mktemp -d)"

            unzip -q "$nupkg" -d "$dir"

            # Remove known non-deterministic pack metadata:
            # - OPC core-properties part name is GUID-based
            # - _rels/.rels references that GUID-based part name
            rm -f "$dir/_rels/.rels" || true
            rm -f "$dir/package/services/metadata/core-properties/"*.psmdcp || true

            # Hash remaining files deterministically (stable ordering)
            (
              cd "$dir"
              find . -type f -print0 | sort -z | xargs -0 sha256sum
            ) > "$out"

            rm -rf "$dir"
          }

          # Compare two packages and print a useful diff (file list + per-file hash diff)
          compare_packages() {
            local p1="$1"
            local p2="$2"
            local name="$3"

            local m1="/tmp/${name}.repro1.manifest"
            local m2="/tmp/${name}.repro2.manifest"

            normalize_manifest "$p1" "$m1"
            normalize_manifest "$p2" "$m2"

            if ! diff -u "$m1" "$m2" >/tmp/${name}.diff; then
              echo "::group::‚ùå Package differs (normalized): $name"
              echo "repro1: $p1"
              echo "repro2: $p2"
              echo ""
              echo "Diff (sha256sum lines):"
              cat "/tmp/${name}.diff"
              echo "::endgroup::"
              return 1
            else
              echo "‚úÖ Deterministic (normalized): $name"
            fi
          }

          mkdir -p /tmp/nupkg-diff

          # Collect all nupkgs in each folder
          mapfile -t P1 < <(ls -1 artifacts/repro1/*.nupkg 2>/dev/null | sort)
          mapfile -t P2 < <(ls -1 artifacts/repro2/*.nupkg 2>/dev/null | sort)

          if [[ "${#P1[@]}" -eq 0 || "${#P2[@]}" -eq 0 ]]; then
            echo "No .nupkg files found in one or both directories."
            echo "repro1 count: ${#P1[@]}"
            echo "repro2 count: ${#P2[@]}"
            exit 1
          fi

          # Compare sets by filename (basename)
          printf "%s\n" "${P1[@]##*/}" | sort > /tmp/repro1.names
          printf "%s\n" "${P2[@]##*/}" | sort > /tmp/repro2.names

          if ! diff -u /tmp/repro1.names /tmp/repro2.names >/tmp/nupkg-names.diff; then
            echo "::group::‚ùå Package sets differ between repro1 and repro2"
            cat /tmp/nupkg-names.diff
            echo "::endgroup::"
            exit 1
          fi

          # Build lookup maps basename -> full path
          declare -A MAP1 MAP2
          for p in "${P1[@]}"; do MAP1["$(basename "$p")"]="$p"; done
          for p in "${P2[@]}"; do MAP2["$(basename "$p")"]="$p"; done

          # Compare each package
          failed=0
          while IFS= read -r name; do
            if ! compare_packages "${MAP1[$name]}" "${MAP2[$name]}" "$name"; then
              failed=1
            fi
          done < /tmp/repro1.names

          if [[ "$failed" -ne 0 ]]; then
            echo ""
            echo "One or more packages were not deterministic (normalized)."
            exit 1
          fi

      - name: Upload package artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-packages-repro
          path: |
            artifacts/repro1/*.nupkg
            artifacts/repro2/*.nupkg
          if-no-files-found: ignore

      - name: Upload normalized package diffs
        if: failure() && steps.compare.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: nupkg-normalized-diffs
          path: |
            /tmp/*.manifest
            /tmp/*.diff
            /tmp/repro1.names
            /tmp/repro2.names
            /tmp/nupkg-names.diff

      - name: Collect quality metrics
        if: always()
        id: quality_metrics
        shell: bash
        run: |
          set -euo pipefail

          mkdir -p metrics/quality

          format_outcome="${{ steps.format_gate.outcome }}"
          build_outcome="${{ steps.build_gate.outcome }}"
          unit_outcome="${{ steps.test_unit.outcome }}"
          integration_outcome="${{ steps.test_integration.outcome }}"
          coverage_collect_outcome="${{ steps.coverage_collect.outcome }}"
          coverage_verify_outcome="${{ steps.coverage_verify.outcome }}"
          pack1_outcome="${{ steps.pack_repro1.outcome }}"
          pack2_outcome="${{ steps.pack_repro2.outcome }}"
          compare_outcome="${{ steps.compare.outcome }}"

          test_passed=0
          test_failed=0
          test_skipped=0
          trx_count=0

          while IFS= read -r trx; do
            trx_count=$((trx_count + 1))
            p=$(sed -n 's/.*passed="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            f=$(sed -n 's/.*failed="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            ne=$(sed -n 's/.*notExecuted="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            nr=$(sed -n 's/.*notRunnable="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            [[ -z "$p" ]] && p=0
            [[ -z "$f" ]] && f=0
            [[ -z "$ne" ]] && ne=0
            [[ -z "$nr" ]] && nr=0
            test_passed=$((test_passed + p))
            test_failed=$((test_failed + f))
            test_skipped=$((test_skipped + ne + nr))
          done < <(find artifacts/test-results -type f -name "*.trx" 2>/dev/null | sort || true)

          coverage_file="$(find tests -type f -name "coverage.cobertura.xml" | head -n1 || true)"
          line_rate=""
          branch_rate=""
          if [[ -n "$coverage_file" ]]; then
            line_rate="$(sed -n 's/.*line-rate="\([0-9.]\+\)".*/\1/p' "$coverage_file" | head -n1)"
            branch_rate="$(sed -n 's/.*branch-rate="\([0-9.]\+\)".*/\1/p' "$coverage_file" | head -n1)"
          fi

          line_min="$(awk '/lineMin:/{print $2; exit}' docs/30-contracts/test-gate.contract.yaml || true)"
          branch_min="$(awk '/branchMin:/{print $2; exit}' docs/30-contracts/test-gate.contract.yaml || true)"

          line_pct="n/a"
          branch_pct="n/a"
          line_threshold_pct="n/a"
          branch_threshold_pct="n/a"
          if [[ -n "$line_rate" ]]; then
            line_pct="$(awk -v v="$line_rate" 'BEGIN { printf "%.2f%%", v * 100 }')"
          fi
          if [[ -n "$branch_rate" ]]; then
            branch_pct="$(awk -v v="$branch_rate" 'BEGIN { printf "%.2f%%", v * 100 }')"
          fi
          if [[ -n "$line_min" ]]; then
            line_threshold_pct="$(awk -v v="$line_min" 'BEGIN { printf "%.2f%%", v * 100 }')"
          fi
          if [[ -n "$branch_min" ]]; then
            branch_threshold_pct="$(awk -v v="$branch_min" 'BEGIN { printf "%.2f%%", v * 100 }')"
          fi

          package_count="$(find artifacts/repro1 -maxdepth 1 -type f -name "*.nupkg" 2>/dev/null | wc -l | tr -d ' ')"
          package_details=""
          while IFS= read -r nupkg; do
            name="$(basename "$nupkg")"
            base="${name%.nupkg}"
            if [[ "$base" =~ ^(.+)\.([0-9]+\.[0-9]+\.[0-9]+([.-].+)?)$ ]]; then
              pkg="${BASH_REMATCH[1]}"
              ver="${BASH_REMATCH[2]}"
            else
              pkg="$base"
              ver="unknown"
            fi
            if [[ -z "$package_details" ]]; then
              package_details="${pkg} ${ver}"
            else
              package_details="${package_details}; ${pkg} ${ver}"
            fi
          done < <(find artifacts/repro1 -maxdepth 1 -type f -name "*.nupkg" 2>/dev/null | sort || true)
          [[ -z "$package_details" ]] && package_details="none"

          cat > metrics/quality/quality-metrics.json <<EOF
          {
            "workflow": "Quality Gate",
            "job": "verify",
            "status": "${{ job.status }}",
            "gates": {
              "format": "${format_outcome}",
              "build": "${build_outcome}",
              "tests": {
                "unit": "${unit_outcome}",
                "integration": "${integration_outcome}",
                "passed": ${test_passed},
                "failed": ${test_failed},
                "skipped": ${test_skipped},
                "trx_count": ${trx_count}
              },
              "coverage": {
                "collect": "${coverage_collect_outcome}",
                "verify": "${coverage_verify_outcome}",
                "line_pct": "${line_pct}",
                "branch_pct": "${branch_pct}",
                "line_threshold_pct": "${line_threshold_pct}",
                "branch_threshold_pct": "${branch_threshold_pct}"
              },
              "packaging": {
                "pack_repro1": "${pack1_outcome}",
                "pack_repro2": "${pack2_outcome}",
                "compare": "${compare_outcome}",
                "count": ${package_count},
                "details": "${package_details}"
              }
            }
          }
          EOF

      - name: Upload quality metrics artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: quality-metrics
          path: metrics/quality/quality-metrics.json

      - name: Write quality summary
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          format_outcome="${{ steps.format_gate.outcome }}"
          build_outcome="${{ steps.build_gate.outcome }}"
          unit_outcome="${{ steps.test_unit.outcome }}"
          integration_outcome="${{ steps.test_integration.outcome }}"
          coverage_collect_outcome="${{ steps.coverage_collect.outcome }}"
          coverage_verify_outcome="${{ steps.coverage_verify.outcome }}"
          pack1_outcome="${{ steps.pack_repro1.outcome }}"
          pack2_outcome="${{ steps.pack_repro2.outcome }}"
          compare_outcome="${{ steps.compare.outcome }}"

          to_status() {
            local outcome="$1"
            if [[ "$outcome" == "success" ]]; then
              echo "‚úÖ"
            elif [[ "$outcome" == "failure" ]]; then
              echo "‚ùå"
            else
              echo "‚ö†Ô∏è"
            fi
          }

          tests_passed=0
          tests_failed=0
          tests_skipped=0
          trx_count=0
          while IFS= read -r trx; do
            trx_count=$((trx_count + 1))
            p=$(sed -n 's/.*passed="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            f=$(sed -n 's/.*failed="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            ne=$(sed -n 's/.*notExecuted="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            nr=$(sed -n 's/.*notRunnable="\([0-9]\+\)".*/\1/p' "$trx" | head -n1)
            [[ -z "$p" ]] && p=0
            [[ -z "$f" ]] && f=0
            [[ -z "$ne" ]] && ne=0
            [[ -z "$nr" ]] && nr=0
            tests_passed=$((tests_passed + p))
            tests_failed=$((tests_failed + f))
            tests_skipped=$((tests_skipped + ne + nr))
          done < <(find artifacts/test-results -type f -name "*.trx" 2>/dev/null | sort || true)

          coverage_file="$(find tests -type f -name "coverage.cobertura.xml" | head -n1 || true)"
          line_rate=""
          branch_rate=""
          if [[ -n "$coverage_file" ]]; then
            line_rate="$(sed -n 's/.*line-rate="\([0-9.]\+\)".*/\1/p' "$coverage_file" | head -n1)"
            branch_rate="$(sed -n 's/.*branch-rate="\([0-9.]\+\)".*/\1/p' "$coverage_file" | head -n1)"
          fi

          line_min="$(awk '/lineMin:/{print $2; exit}' docs/30-contracts/test-gate.contract.yaml || true)"
          branch_min="$(awk '/branchMin:/{print $2; exit}' docs/30-contracts/test-gate.contract.yaml || true)"

          line_pct="n/a"
          branch_pct="n/a"
          line_threshold="n/a"
          branch_threshold="n/a"
          coverage_status="‚ùå"
          coverage_note="‚ùå Metrics missing"
          if [[ -n "$line_rate" && -n "$branch_rate" && -n "$line_min" && -n "$branch_min" ]]; then
            line_pct="$(awk -v v="$line_rate" 'BEGIN { printf "%.2f%%", v * 100 }')"
            branch_pct="$(awk -v v="$branch_rate" 'BEGIN { printf "%.2f%%", v * 100 }')"
            line_threshold="$(awk -v v="$line_min" 'BEGIN { printf ">= %.2f%%", v * 100 }')"
            branch_threshold="$(awk -v v="$branch_min" 'BEGIN { printf ">= %.2f%%", v * 100 }')"
            coverage_note="Branch ${branch_pct}"
            if [[ "$coverage_verify_outcome" == "success" ]]; then
              coverage_status="‚úÖ"
            fi
          fi

          package_count="$(find artifacts/repro1 -maxdepth 1 -type f -name "*.nupkg" 2>/dev/null | wc -l | tr -d ' ')"
          package_details=""
          while IFS= read -r nupkg; do
            name="$(basename "$nupkg")"
            base="${name%.nupkg}"
            if [[ "$base" =~ ^(.+)\.([0-9]+\.[0-9]+\.[0-9]+([.-].+)?)$ ]]; then
              pkg="${BASH_REMATCH[1]}"
              ver="${BASH_REMATCH[2]}"
            else
              pkg="$base"
              ver="unknown"
            fi
            if [[ -z "$package_details" ]]; then
              package_details="${pkg} ${ver}"
            else
              package_details="${package_details}; ${pkg} ${ver}"
            fi
          done < <(find artifacts/repro1 -maxdepth 1 -type f -name "*.nupkg" 2>/dev/null | sort || true)
          [[ -z "$package_details" ]] && package_details="‚ùå Metrics missing"

          packaging_status="‚ùå"
          if [[ "$pack1_outcome" == "success" && "$pack2_outcome" == "success" && "$compare_outcome" == "success" && "$package_count" -gt 0 ]]; then
            packaging_status="‚úÖ"
          fi

          tests_status="‚ùå"
          tests_metric="‚ùå Metrics missing"
          if [[ "$trx_count" -gt 0 ]]; then
            tests_metric="${tests_passed} pass / ${tests_failed} fail / ${tests_skipped} skipped"
            if [[ "$tests_failed" -eq 0 && "$unit_outcome" == "success" && "$integration_outcome" == "success" ]]; then
              tests_status="‚úÖ"
            fi
          fi

          build_status="$(to_status "$build_outcome")"
          format_status="$(to_status "$format_outcome")"
          overall="‚úÖ Passed"
          if [[ "${{ job.status }}" != "success" ]]; then
            overall="‚ùå Failed"
          fi

          {
            echo "# CI Quality Summary"
            echo ""
            echo "**Workflow:** ${{ github.workflow }}"
            echo "**Ref:** ${{ github.ref_name }}"
            echo "**Commit:** ${{ github.sha }}"
            echo "**Trigger:** ${{ github.event_name }}"
            echo "**Result:** $overall"
            echo ""
            echo "## Executive Gates"
            echo "| Gate | Status | Metric | Threshold | Notes |"
            echo "|---|---|---:|---:|---|"
            echo "| Build | $build_status | Deterministic release build | Success | -warnaserror enabled |"
            echo "| üß™ Tests | $tests_status | $tests_metric | 0 fails | TRX files: ${trx_count} |"
            echo "| üìä Coverage | $coverage_status | Line ${line_pct} | ${line_threshold} | ${coverage_note} (branch gate: ${branch_threshold}) |"
            echo "| üåÄ Fuzzing | N/A | Not configured | n/a | n/a |"
            echo "| üß¨ Mutation | N/A | Not run in this workflow | n/a | Separate scheduled workflow |"
            echo "| üì¶ Packaging | $packaging_status | ${package_count} packages | >= 1 | ${package_details} |"
            echo "| üìù Format/Analyzers | $format_status | dotnet format --verify-no-changes | Success | Policy gate |"
            echo ""
            echo "## Artifacts"
            echo "- coverage-cobertura"
            echo "- quality-packages-repro"
            echo "- nupkg-normalized-diffs (on package compare failure)"
            echo "- quality-metrics"
          } >> "$GITHUB_STEP_SUMMARY"

          if [[ "$overall" != "‚úÖ Passed" ]]; then
            {
              echo ""
              echo "## üìù Action Required"
              echo "- Start from the first ‚ùå gate above."
              echo "- For coverage failures, inspect `coverage-cobertura` and `docs/30-contracts/test-gate.contract.yaml`."
              echo "- For package determinism failures, open `nupkg-normalized-diffs`."
            } >> "$GITHUB_STEP_SUMMARY"
          fi
